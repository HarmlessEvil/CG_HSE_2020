#pragma kernel ComputeHarmonics

#define PI            3.14159265359f
#define TWO_PI        6.28318530718f
#define FOUR_PI       12.56637061436f
#define INV_PI        0.31830988618f
#define INV_TWO_PI    0.15915494309f
#define INV_FOUR_PI   0.07957747155f
#define HALF_PI       1.57079632679f
#define INV_HALF_PI   0.636619772367f

#define Y_0_0         (2 * sqrt(PI))

#define Y_1_INV_1(v)  (0.2387324146f * v.y) // (-sqrt(3) / (2 * sqrt(PI))) * y
#define Y_1_0(v)      (0.2387324146f * v.z) // (sqrt(3) / (2 * sqrt(PI))) * z
#define Y_1_1(v)      (0.2387324146f * v.x) // (sqrt(3) / (2 * sqrt(PI))) * x

#define Y_2_INV_2(v)  (1.1936620732f * v.y * v.x) // (sqrt(15) / (2 * sqrt(PI))) * y * x
#define Y_2_INV_1(v)  (1.1936620732f * v.y * v.z) // (-sqrt(15) / (2 * sqrt(PI))) * y * z
#define Y_2_0(v)      (0.09947183946f * (3 * v.z * v.z - 1)) // (sqrt(5) / (4 * sqrt(PI))) * (3 * z^2 - 1)
#define Y_2_1(v)      (1.1936620732f * v.x * v.z) // (-sqrt(15) / (2 * sqrt(PI))) * x * z
#define Y_2_2(v)      (0.2984155183f * (v.x * v.x - v.y * v.y)) // (-sqrt(15) / (4 * sqrt(PI))) * (x^2 - y^2)

RWStructuredBuffer<float4> SH_0_1_r;
RWStructuredBuffer<float4> SH_0_1_g;
RWStructuredBuffer<float4> SH_0_1_b;

RWStructuredBuffer<float4> SH_2_r;
RWStructuredBuffer<float4> SH_2_g;
RWStructuredBuffer<float4> SH_2_b;

RWStructuredBuffer<float4> SH_2_rgb;

TextureCube<half4> _Env;
SamplerState samplerLinearRepeat;

uint Hash(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

float Random(uint seed)
{
    return float(Hash(seed)) / 4294967295.0; // 2^32-1
}

float3 SampleColor(float3 direction)
{   
    float4 tex = _Env.SampleLevel(samplerLinearRepeat, direction, 0);
    return tex.rgb;
}

float pow2(float x)
{
    return x * x;
}

float4 Evaluate_SH_0_1(float3 normal)
{
    float3 c = normal.xyz * 3.0f / 4.0f / PI;
    return float4(
        c,
        1.0f / 4.0f / PI
    );
}

float4 Evaluate_SH_2(float3 normal)
{
    float4 vB = normal.xyzz * normal.yzxz;
    float3 c = vB.xyz * 15 / 4 / PI;
    return float4(
         c.x,
         c.y,
         c.z,
        (3.f * vB.w - 1.f) * 5 / 16.0f / PI
    );
}

[numthreads(1024, 1, 1)]
void ComputeHarmonics(uint id : SV_DispatchThreadID)
{
    const int THREADS = 1024;
    const int SAMPLES = 100;
    
    // See SH.shader for more details
    float4 results[7] = {
        float4(0, 0, 0, 0), // SH_0_1_r
        float4(0, 0, 0, 0), // SH_0_1_g
        float4(0, 0, 0, 0), // SH_0_1_b
        
        float4(0, 0, 0, 0), // SH_2_r
        float4(0, 0, 0, 0), // SH_2_g
        float4(0, 0, 0, 0), // SH_2_b
        
        float4(0, 0, 0, 0), // SH_2_rgb
    };
    
    // TASK: project light from _Env to spherical harmonic coefficients and store them in results[]
    for (int i = 0; i < SAMPLES; i++)
    {
        uint seed = THREADS * id + i;
        float u = Random(2 * seed);
        float v = Random(2 * seed + 1);
        float phi = u * TWO_PI;
        float cosTheta = 2 * v - 1;
        float sinTheta = sqrt(1 - cosTheta * cosTheta);
        
        float3 sampleDir = float3(
            cos(phi) * sinTheta,
            sin(phi) * sinTheta,
            cosTheta
        );
    
        float3 sample = SampleColor(sampleDir);
        
        float4 sh_0_1 = Evaluate_SH_0_1(sampleDir);
        sh_0_1.w *= PI;
        sh_0_1.xyz *= 2 * PI / 3;
        for (int c = 0; c < 3; c++)
        {
            results[c] += sample[c] * sh_0_1;
        }
        
        float4 sh_2 = Evaluate_SH_2(sampleDir);
        sh_2 *= PI / 4;
        
        for (c = 0; c < 3; c++)
        {
            results[3 + c] += sample[c] * sh_2;
        }
        
        results[6].rgb += sample * 15 / 16 / PI * (sampleDir.x*sampleDir.x - sampleDir.y*sampleDir.y);
        results[6].rgb *= PI / 4;
    }
    
    for (i = 0; i < 7; i++)
    {
        results[i] = results[i] * 4 / SAMPLES;
    }
    
    //for (int c = 0; c < 3; c++)
    //{
    //    // Precomputing coefficients of max(0, cos(theta) for L=0
    //    results[c].w *= PI; 
    //    // Precomputing coefficients of max(0, cos(theta) for L=1
    //    results[c].xyz *= PI * 2 / 3;
    //}
    //
    //for (c = 0; c < 4; c++)
    //{
    //    // Precomputing coefficients of max(0, cos(theta) for L=2
    //    results[3 + c] *= PI / 4;
    //} 
    
    //for (int c = 0; c < 7; c++) 
    //{
    //    results[c] *= PI * 4;
    //}
    
    SH_0_1_r[id] = results[0];
    SH_0_1_g[id] = results[1];
    SH_0_1_b[id] = results[2];
    
    SH_2_r[id] = results[3];
    SH_2_g[id] = results[4];
    SH_2_b[id] = results[5];    
    
    SH_2_rgb[id] = results[6];    
}
